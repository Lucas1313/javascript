<?php
/**
 * Class NestedDataObjectField
 * Generates a set of accordions in the CMS to manage
 *
 * @author Luc Martin at Clorox
 * @version $ID
 */
class NestedDataObjectField extends ToggleCompositeField {

    public $name;

    public function __construct($name, $title, $args) {
        NestedDataObjectField::include_files();
        $this->name = $name;
        $this->generateNestedDataObject($args);

    }

    static function include_files(){
        Requirements::css('NestedDataObjectField/css/NestedDataObjectField.css');
    }
    /**
     * function updateNestedDataObjects
     * Method to update a the contain of NestedDataObjects
     * Will update data when the fields representing the newNestedObject are changed
     *
     * @author Luc Martin
     * @version $ID
     */
    static public function updateNestedDataObjects($caller) {

        // test if we have any object in this

        if (isset($_SESSION['nestedObjects']) && count($_SESSION['nestedObjects']) > 1) {

            // iterate through the saved data
            foreach ($_SESSION['nestedObjects'] as $key => $nestedObject) {
                // test if there is a nested object
                if (count($nestedObject) > 1) {

                    // the parent
                    $parent = $nestedObject['parent'];

                    // the object
                    $objectToSave = $nestedObject['object'];
                    $objectToSaveClass = $nestedObject['objectClass'];

                    // the specific ID of the object
                    $objectId = $nestedObject['objectId'];

                    // now the fields
                    $fieldType = $nestedObject['field'];

                    // the local field where the user can edit data
                    $objectLocalField = $nestedObject['localField'];
                    $localFieldId = $nestedObject['localFieldId'];

                    // the data in the field
                    $objectNewData = $caller -> $objectLocalField;

                    // get the object from the database for update
                    $dbObject = $objectToSaveClass::get() -> filter(array('ID' => $objectId)) -> first();

                    // there is a Unlink checkbox in the fields so the user can unlink the object
                    $UnlinkFieldName = $localFieldId . 'Unlink';

                    $Unlink = $caller -> $UnlinkFieldName;
                    // test if the checkbox is clicked
                    if ($Unlink == 1) {
                        // if clicked we remove the link in between the parent and the object
                        $parent -> $objectToSave() -> remove($dbObject);
                    }
                    elseif (!empty($objectNewData) && $objectNewData !== '') {
                        // update the object with the new data
                        $dbObject -> $fieldType = $objectNewData;
                        // write the object
                        $dbObject -> write();
                    }
                }
            }
        }
        // Switch to get a clean session object next time
        $_SESSION['reset'] = true;
    }



    /**
     * function generateNewNestedDataObjectItem()
     * Method to generate a nested DataObject from the new dataObject fields
     * @author Luc Martin
     * @version $ID
     */
    static public function generateNewNestedDataObjectItem($caller) {

        // Test if there is a job to be done
        if(empty($_SESSION['newNestedObjects'])){
            return;
        }

        // iterate through the top level object generated by the accordion creation
        foreach ($_SESSION['newNestedObjects'] as $objectToAdd => $newNestedObjectData) {

            // test if there is an accordion
            if (!empty($newNestedObjectData[0]['objectClass'])) {

                // the Object class
                $objectToAddClass = $newNestedObjectData[0]['objectClass'];
                $newDataObject = null;

                // iterate Through the fields
                foreach ($newNestedObjectData as $k => $objData) {

                    // update class
                    $objectToAddClass = $objData['objectClass'];

                    // if the Object doesn't exists create a new one
                    if (empty($newDataObject)) {
                        $newDataObject = new $objectToAddClass();
                    }

                    // the field
                    $fieldToAdd = $objData['field'];

                    // the Local field where user can update the data
                    $localField = $objData['localField'];

                    // the actual data
                    $localFieldData = $caller -> $localField;

                    // Test if there is indeed data to add
                    if ($localFieldData !== 'Add ' . $fieldToAdd && $localFieldData !== '' && !empty($localFieldData)) {

                        // there is data let generate the object
                        $parent = $objData['parent'];
                        $fieldToAdd = $objData['field'];
                        $newDataObject -> $fieldToAdd = $localFieldData;

                        // reset the fields to original form
                        $caller -> $localField = 'Add ' . $fieldToAdd;

                        // write the new Object
                        $newDataObject -> write();

                        // set relationship
                        $parent = $objData['parent'];

                        // add relationship
                        $parent -> $objectToAdd() -> add($newDataObject);
                    }
                }
            }
        }
    }

     /**
     * function generateNestedDataObject()
     * Generates a nested set of accordions from nested DataObjects
     * @author Luc Martin
     * @version $ID
     */
    private function generateNestedDataObject($args) {

        // Cleanup the old stuff in the session
        if(!isset($_SESSION['nestedObjects']) || $_SESSION['reset'] == true){
            $_SESSION['nestedObjects'] = null;
            $_SESSION['nestedObjects'] = array();
        }

        // Cleanup session and init the new objects
        if(!isset($_SESSION['newNestedObjects']) || $_SESSION['reset'] == true){
            $_SESSION['newNestedObjects'] = null;
            $_SESSION['newNestedObjects'] = array();
            $_SESSION['reset'] = false;
        }

        // Unique ID for the fields
        $_SESSION['fieldIterator'] = 0;

        // the variables to process

        // the parent specific identifier
        $parent = $args['parent'];

        // the parent class (  $many_many = array( 'parent' => 'parentClass'); )
        $parentClass = $args['parentClass'];

        // The object
        $object = $args['object'];

        // the Object class
        $objectClass = $args['objectClass'];

        //option fields
        $optionsSetSources = $args['optionsSetSources'];

        // The fields we want to edit
        $fields = $args['fields'];

        // The recursions will grab relationships at deeper levels
        $recursions = isset($args['recursions']) ? $args['recursions'] : null;

        // the database ID for the specific parent
        $parentId = isset($args['parentId']) ? $args['parentId'] : $this -> ID;

        // is there an image path to display? Usefull for images path and names set by convention
        $addImageInfo = isset($args['addImageInfo']) ? $args['addImageInfo'] : false;

        // this is the session object to save the data for later use (Update fields)
        if (empty($_SESSION['nestedObjects'])) {
            // init the session
            $_SESSION['nestedObjects'] = array( array( array( array())));
        }

        // get all the actually related objects
        $allObjects = $parent -> $object();

        // Test if there is one at least
        $testObject = $allObjects -> first();

        $iterator = 0;
        $allFields = array();
        $allAccordions = array();

        // Start the div with some styling
        //TODO extract the view from the controller (use a render with?)
        $allAccordions[] = new LiteralField('all' . $object . 'Header', '<div style="border:3px solid; border-radius:7px; box-shadow:1px 1px 15px #777; padding:30px; margin:20px;">');

        // Build the ID
        $localFieldId = $parentClass . '_' . $parentId . '_' . $object.'_'.$_SESSION['fieldIterator'].'_';

        // Iterate through all the Objects owned by parent

        // test if there is an object to render
        if (!empty($testObject)) {

            // iterate through all local objects
            foreach ($allObjects as $key => $singleObject) {

                // increase the field iterator to make sure there is a unique ID for the fields
                $_SESSION['fieldIterator'] = $_SESSION['fieldIterator'] + 1;

                // the id of the local field
                $localFieldId = $parentClass . '_' . $parentId . '_' . $object . '_' . $singleObject -> ID . '_' . $_SESSION['fieldIterator'] . '_';

                // the Unlink CheckboxField
                $allFields[$singleObject -> ID][] = new CheckboxField($localFieldId . 'Unlink', 'Unlink ' . $singleObject -> Title . ' Object type: ' . $object . '');
                $allFields[$singleObject -> ID][] = new ReadOnlyField($localFieldId . 'ID', 'ID', $singleObject -> ID);

                // Render all fields
                foreach ($fields as $field => $fieldType) {

                    // The field
                    if($fieldType == 'OptionsetField'){
                        error_log('optionset');
                        $allFields[$singleObject -> ID][] = new $fieldType($Name = $localFieldId . $field, $title = $field, $source = $optionsSetSources[$field], $value = $singleObject ->$field);
                    }else{
                        //TODO add a field type to the field name
                        $allFields[$singleObject -> ID][] = new $fieldType($localFieldId . $field, $field, $singleObject -> $field);
                    }

                    // save the data to the global object for later
                    $_SESSION['nestedObjects'][] = array(
                        'parent' => $parent,
                        'parentClass' => $parentClass,
                        'parentId' => $parentId,
                        'object' => $object,
                        'objectClass' => $objectClass,
                        'objectId' => $singleObject -> ID,
                        'field' => $field,
                        'localField' => $localFieldId . $field,
                        'localFieldId' => $localFieldId
                    );
                }

                // Image info
                if ($addImageInfo) {

                    // init
                    $imagePath = '';

                    // Image info is an array so we can add as many lines of information as we need to
                    foreach ($addImageInfo as $key => $imageInfo) {
                        $filename = '';
                        if($imageInfo['fields'] ){
                            foreach($imageInfo['fields'] as $field){
                                $filename .= $singleObject->$field;
                            }
                        }
                        //TODO do we need to build this as a template?
                        $imagePath .= '<div style="margin: 5px 20px ; font-size:14px;">The path for the ' . $key . ' image is: ' . $imageInfo['path'] . '<strong>' . $this -> generateCodename($filename) . '.' . $imageInfo['extension'] . '</strong></div>';

                    }
                    // Push the fields
                    $allFields[$singleObject -> ID][] = new LabelField($localFieldId . '_' . $key, '<div style="margin:5px 10px; border:solid 1px; border-radius:7px; box-shadow: 1px 1px 5px #777; padding:10px;">' . $imagePath . '</div>');
                }

                // recursions to generate the Nested Data Object
                //TODO Probably need to be a lazy loader on that one
                if (!empty($recursions)) {

                    // default to null
                    $recursions['recursions'] = isset($recursions['recursions']) ? $recursions['recursions'] : null;

                    // Recurse
                    //TODO How can we do this in a lazy way???

                    $allFields[$singleObject -> ID][] = new NestedDataObjectField('test','test',array(
                        'parent' => $singleObject,
                        'parentClass' => $objectClass,
                        'parentId' => $singleObject -> ID,
                        'object' => $recursions['object'],
                        'objectClass' => $recursions['objectClass'],
                        'fields' => $recursions['fields'],
                        'recursions' => $recursions['recursions'],
                        'addImageinfo' => $recursions['addImageInfo']
                    ));
                }

                // Getting ready to stuff the accordion with the fields
                $allObjects = new FieldList($allFields[$singleObject -> ID]);

                $name = $singleObject -> Name;
                //error_log('The accordion will be named '.$name);
                if(empty($name)){
                    //error_log('Name is empty ');
                    $name = $singleObject -> Title;
                }


                // Generate the accordion
                $allAccordions[] = new ToggleCompositeField($localFieldId . 'Accordion', '' . $object . ':<span style="margin: 0 0 0 30px;">' . $name . '</span>', $allObjects);

            }
        }

        // Some formatting for the "New" Object creation area
        $allAccordions[] = new LiteralField($localFieldId . '_' . 'New' . $object . 'Header', '<div style="border:1px solid; border-radius:7px; box-shadow:1px 1px 5px #777; padding:20px; margin:20px;">');
        $allAccordions[] = new HeaderField($localFieldId . 'Header', 'ADD New ' . $object . ': ');

        // here we generate the "New" fields
        foreach ($fields as $field => $fieldType) {

            // because we have the same name in fields, we increase the iterator
            $_SESSION['fieldIterator'] = $_SESSION['fieldIterator'] + 1;

            // unique ID for the New field
            $newTextFieldId = $parentClass . '_' . $parentId.'_'.$object . '_' . $_SESSION['fieldIterator'] . '_NEW_' . $field;

            // Text field
            //TODO Would be cool to have a Field type for this
            if($fieldType == 'OptionsetField'){
                error_log('optionset');
                //$allFields[$singleObject -> ID][] = new $fieldType($Name = $localFieldId . $field, $title = $field, $source = array('1','2','3'));
            }else{
                $allAccordions[] = new $fieldType($newTextFieldId, $field, 'Add ' . $field);
            }
            // register the field to the session Object
            $_SESSION['newNestedObjects'][$object][] = array(
                'parent' => $parent,
                'parentClass' => $parentClass,
                'parentId' => $parentId,
                'object' => $object,
                'objectClass' => $objectClass,
                'field' => $field,
                'localField' => $newTextFieldId
            );
        }
        // close down the formatting for the div
        $allAccordions[] = new LiteralField('new' . $object . 'Footer', '</div>');

        // close down the whole section formatting
        $allAccordions[] = new LiteralField('all' . $object . 'Footer', '</div>');
        $allAccordionsFields = new FieldList($allAccordions);

        // Package and ship!
        return parent::__construct($parentClass . '_' . $parentId . '_' . $object . 'Toogle', '<div style="margin:5px 10px;">' . $object . ':', $allAccordions);

    }

    /**
     * function generatecodeName
     * Method to Generate a code name for the Product
     * Necessary because some products are not coming from the API
     * This method should remove all special characters and spaces then remove all cap letters
     *
     * @access public
     * @return String a string without spaces or special characters
     */
    public function generateCodeName($str) {

        $str = preg_replace('/([^A-Za-z0-9])/', "", $str);
        $str = strtolower($str);

        return $str;
    }

}
